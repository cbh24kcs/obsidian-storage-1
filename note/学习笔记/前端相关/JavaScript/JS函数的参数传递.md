结论：**在JS中，基本类型按值传递，引用类型按共享传递**

**按值传递**

复制值，两块内存，修改之间互不干扰

按值传递由于每次都需要克隆副本，对一些复杂类型，性能较低

**按引用传递**

复制引用，一块内存，修改其中一个会影响到另一个，也称为传地址

方法调用时，实际参数是对象(或数组)，这时实际参数与形式参数是同一个地址，在方法执行中，对形式参数的操作实际上就是对实际参数的操作，这个结果在方法结束后被保留了下来，所以方法执行中形式参数的改变将会影响实际参数。

按引用传递会使函数调用的追踪更加困难，有时也会引起一些微妙的BUG。

**按共享传递（也叫按对象传递、按对象共享传递）**

复制引用，两块内存，可以通过引用修改内存的值

但是如果修改引用值的话，不会对实参产生影响

函数接受对象实参引用的副本，在共享传递中对函数形参的赋值，不会影响实参的值

**传引用 ≠ 传引用值**

-   传引用：传的一方与被传的一方，是同一块内存，而且存储的都是同一个引用值（地址值）
-   传引用值：传的一方与被传的一方，不是同一块内存，但是存储的是同一个引用值（地址值）


对应的一段C++分析的代码：
```c++
#include <iostream>
using namespace std;

void fun1(int x) 
{
    x = 4;
    cout << "fun1: 里面x的地址:" << &x << endl;
}

void fun2(int &x) 
{
    x = 4;
    cout << "fun2: 里面x的地址:" << &x << endl;
}

void fun3(int* px) 
{
    *px = 4;
    cout << "fun3: 里面px存储的地址:" << px << endl;
}


int main()
{
    int x = 3;
    // 按值传递
    // 相当于复制了内存中的值
    // 实参与形参的地址不同
    // 实参与形参使用的内存也不同
    fun1(x);
    cout << "x = " << x << endl;

    // 按引用传递
    // 实参与形参的地址其实是一样的
    // 实参与形参引用的内存也是一样的
    x = 3;
    cout << "fun2: 外面的x的地址:" << &x << endl;
    fun2(x);
    cout << "x = " << x << endl;

    // 按共享传递（传递地址）
    // C++中其实没有按共享传递，但是可以用指针模拟
    // 实参与形参的地址不同
    // 形参保存了实参的地址
    // 所以实参与形参可以访问同一个内存区域
    // 修改共享本身的值，不会影响实参
    x = 3;
    fun3(&x);
    cout << "x = " << x << endl;


    return 0;
}

```